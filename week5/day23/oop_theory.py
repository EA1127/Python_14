"""

Основные понятия ООП:
- класс
- объект класса (экземпляры)
- принципы ООП:
    * наследлование
    * инкапсуляция
    * полиморфизм
    - абстракция
    - композиция
    - агрегация
    - множественное наследование

1.
class NameClass:
    код_тела_класса

2.
class ДочернийКласс (Родитель-1, Родитель2)
    код_тела_класса

3. создание объекта класса:
class NameClass:
    код_тела_класса

объект1 = ИмяКласса()
объект1 = ИмяКласса()


*
Введение в ООП.
В Python уже существуют готовые для работы объекты - строки, числа, списки и.т.п, у этих объектов также 
есть свои методы и свойства. Таким же образом, мы можем создавать свои объекты, давать им методы, 
свойства и определять их поведение.

К примеру, создадим шаблон для объектов под названием MyObject:

class MyObject: 
мы хотим чтобы у каждого объекта созданного от класса MyObject было название - name, нам нужно связать 
переменную name с нашим объектом, для этого существует встроенный метод __init__.

Помимо __init__, внутри классов есть метод __new__. Работу данных методов можно представить так, допустим 
у нас есть завод по выпуску автомобилей, __new__ срабатывает тогда, когда мы утвердили идею выпуска 
нового авто, а __init__ срабатывает позже, когда запускается сам процесс сборки новой модели авто. 
На этом этапе мы можем изменить и добавить новые характеристики авто(вид двигателя, цвет кузова и.т.д).

Eсли мы хотим дать всем объектам класса MyObject свойство name, можем переопределить метод __init__:

class MyObject: 
def __init__(self, name): 
  self.name = name 
по умолчанию, метод __init__ принимает один аргумент self, в self хранится ссылка на сам объект, после 
self можем добавлять свои свойства. Чтобы связать эти свойства с объектом, указываем через ссылку на 
объект в self.name свойство name.

Создать объект можно прописав любую переменную и присвоив ее к классу MyObject(), в скобках нужно 
прописать название объекта, а в self попадет сама ссылка на нашу переменную:

object1 = MyObject('первый объект') 
Для объектов созданных от какого-либо класса также часто используется термин-синоним экземпляр класса


**
Введение в ООП.

Мы уже знаем что через метод __init__ можем задать свойства, или как еще их называют аттрибуты экземпляров класса. 
Каждый аттрибут заданный через __init__ привязан отдельно к каждому из объектов класса. Внутри класса, можно также 
создать общие аттрибуты для всех объектов класса, которые называются переменными класса.

К примеру, у нас есть класс SolarSystem - солнечная система:

class SolarSystem: 
  def __init__(self, planet): 
      self.planet = planet 
от этого класса можно создать объекты-планеты.

Для всех объектов солнечной системы есть одна единственная звезда - солнце, поэтому мы можем записать star как 
переменную для всего класса со значением Sun:

class SolarSystem: 
    star = 'Sun' 
    def __init__(self, planet): 
        self.planet = planet  

переменная star будет существовать для любого объекта созданного от данного класса, проверить можно создав 
разные экземпляры класса и выведя для каждого из них переменную star через точку:

first = SolarSystem('Mercury') 
print(first.star) 
second = SolarSystem('Venus') 
print(second.star) 
Получим в терминале вывод:

Sun 
Sun

***
Введение в ООП.
Помимо обычных аттрибутов объектов класса, можно также создавать свойства привязанные к объектам с уже имеющимися значением.

То есть, нам не нужно будет указывать новые значения свойств в __init__ при создании каждого объекта, эти свойства уже 
будут иметь значения по умолчанию и будут привязаны к каждому из объектов класса.

Допустим у нас есть класс:

class Auto: 
   def __init__(self): 
у каждого автомобиля есть свойство пробег - mileage, мы будем полагать что все наши машины масловые, а значит каждый 
объект-авто созданный от нашего класса будет уже иметь пробег равный 0:

class Auto: 
   def __init__(self): 
       self.mileage = 0 
так как, это значение изначально равно 0, мы не будем прописывать его каждый раз при создании объекта-автомобиля, 
а сразу привяжем к объекту через self - self.mileage = 0.

Теперь добавим метод drive, который будет увеличивать наш пробег mileage:

class Auto: 
   def __init__(self): 
       self.mileage = 0 
    
   def drive(self, km): 
       self.mileage += km 
       return self.mileage 
для того, чтобы мы могли изменить аттрибут объекта, нам нужно обращаться к нему через объект, т.е через self, 
поэтому передаем self в параметры метода drive, а вторым параметром будет km - километры.

Внутри метода, добавляем к self.mileage каждый переданный километр и перезаписываем новое значение в переменную 
mileage. В конце, возвращаем пробег с помощью ключевого слова return.

Создадим объект от нашего класса, и применим метод drive:

auto = Auto() 
print(auto.mileage(500)) 
получаем в терминале:

500 


****
В Python есть два специальных метода __str__ и __repr__. Эти методы чаще всего работают без нашего вмешательства, 
к примеру метод __str__ мы никогда напрямую не вызывали, но он срабатывал каждый раз как мы использовали print().

Метод __str__ возвращает понятное человеку, строковое представление объекта. __str__ можно легко переопределять 
внутри класса и изменять вид в котором мы распечатываем объект.

К примеру, у нас есть класс и созданный от него объект, который мы попробуем распечатать:

class MyClass: 
     def __init__(self, name): 
         self.name = name

obj = MyClass('первый объект')

print(obj)
в результате получим данную запись в терминале:

<__main__.MyClass object at 0x7f53ba5948b0> 

однако, если мы перепишем метод __str__, который также как и __init__ принимает в аргументы self, 
можем поменять поведение объекта при использовании print().

Допустим, мы хотим чтобы в терминале выводился атрибут объекта name:

class MyClass: 
     def __init__(self, name): 
         self.name = name 

     def __str__(self): 
         return self.name

obj = MyClass('первый объект') 
print(obj)

здесь мы получили доступ к атрибуту name через ссылку на сам объект в self - self.name, и возвратили 
в качестве конечного результата работы метода __str__ с помощью return.

Получаем в терминале:

    первый объект 

В свою очередь, метод __repr__ возвращает объект в том виде в котором мы можем его распечатать, 
при этом он не заботится о том чтобы запись была понятна обычным людям.

Задача __str__ состоит в том чтобы быть читаемым, задача же __repr__ состоит в том чтобы быть конкретным.

"""

# 1)
# class SomeClass:
#     pass

# 2)
# class A:
#     pass
# a = A() # создание объекта класса или экземпляра класса (instance)
# print(isinstance(a, A)) # проверка: True

# 3)
# a = 4
# print(type(a))  # <class 'int'>

# class int:
#     # свойства
#     pass
# class str:
#     # свойства
#     pass
# class list:
#     # свойства
#     pass

# print(type(int)) # <class 'type'>


# 4) встроенные классы
# int, str, list, tuple, dict, bool, set, frozenset   # <class 'type'>


# 5) создание класса Dog
# class Dog:
#     owner = 'John' # атрибуты или свойства класса Dog
#     name = ''  # атрибуты или свойства класса Dog
#     age = 0    # атрибуты или свойства класса Dog

#     def __init__(self, name, age):  # dog1 --> self
#         self.name = name  # создание атрибута экземпляра класса
#         self.age = age    # создание атрибута экземпляра класса

#     def __str__(self):      # ПЕРЕОПРЕДЕЛЕНИЕ ИМЕНИ ОБЪЕКТА
#         return f'{self.name} {self.age}'

#     def bark(self):  # определение методов экземпляра класса
#         print('gav - gav')

#     def dog_info(self):
#         return f'This is {self.name}, he is {self.age} years old'

#     def birthday(self, cake):
#         self.age += 1
#         self.cake = cake
#         return f'{self.name} is {self.age} now'
    
#     def friends(self, friend):
#         self.friend = friend
#         friend.friend = self

#     # @classmethod
#     # def eat(cls):
#     #     print('yammy - yammy')  # методы самого класса

# dog1 = Dog(name='Rex', age=3)  # объект класса Dog
# dog2 = Dog(name='Boy', age=2)
# dog3 = Dog(name='Lolo', age=1)

# dog1.friends(dog2)
# print(dog1.friend)
# print(dog2.friend.name)
# print(dog1.birthday('chocolate'))
# print(dog1.cake)
# print(dog1) # если не переопределить то выйдет:  <__main__.Dog object at 0x7f477c6fc5b0>
# dog1.bark()
# dog1.name
# dog1.age
# dog1.name = 'Tuzik'  # изменение атрибута экземпляра
# dog1.food = 'pedigree'  # создание нового атрибута экземпляра
# print(dog1.name)
# print(dog1.food)
# print(dog1.age)
# print(dog1.owner)

# print(dog2.birthday('vanila'))
# print(dog2.cake)
# print(dog2)
# dog2.bark()
# dog2.name
# dog2.age
# print(dog2.name)
# print(dog2.age)
# print(dog2.owner)

# print(dog3.birthday('beze'))
# print(dog3.cake)
# print(dog3)
# dog3.bark()
# print(dog3.dog_info())
# dog3.owner = 'Alice'
# print(dog3.owner)  # Alice



# 6) creating class RECTANGLE

# class Rectangle:

#     default_color = 'red'

#     def __init__(self, width, length):
#         self.width = width
#         self.length = length

#     def area(self):
#         return self.width * self.length

# rec1 = Rectangle(4, 6)
# rec2 = Rectangle(2, 7)
# rec2.default_color = 'yellow'
# print(rec1.area())
# print(rec1.width)
# print(rec1.length)
# print(rec1.default_color)

# print(rec2.area())
# print(rec2.default_color)




# 7) creating class CAR

# class Car:

#     car_count = 0

#     def __init__(self):
#         Car.car_count += 1

# car1 = Car()
# print(Car.car_count)
# car2 = Car()
# car3 = Car()
# car4 = Car()
# print(Car.car_count)

