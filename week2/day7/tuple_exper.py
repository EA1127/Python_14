""" Tuple - кортежи"""
"""
Для создания кортежа используются круглые скобки, в которые помещаются его значения, разделенные запятыми:
"""
user = ("Aybek", 23) 
print(user)
# ('Aybek', 23) 

"""
Для создания кортежа из списка можно передать список в функцию tuple(), которая возвратит кортеж:
"""
users_list = ["Aybek", "Ulan", "Nursultan"] 
users_tuple = tuple(users_list) 
print(users_tuple) 
# ("Aybek", "Ulan", "Nursultan")

"""
Обращение к элементам в кортеже происходит также, как и в списке по индексу. 
Индексация начинается также с нуля при получении элементов с начала списка и с -1 при получении элементов с конца списка:
"""
users = ("Aybek", "Ulan", "Nursultan", "Dastan") 
print(users[0]) # Aybek  
print(users[2]) # Nursultan  
print(users[-1]) # Dastan 

# получим часть кортежа со 2 элемента по 4 
print(users[1:4]) # ("Ulan", "Nursultan", "Dastan") 

"""Но так как кортеж - неизменяемый тип (immutable), то мы не сможем изменить его элементы. 
То есть следующая запись работать не будет:"""

users[1] = "Anton"

"""При необходимости мы можем разложить кортеж на отдельные переменные:"""
user = ("Aybek", 22, False) 
name, age, isMarried = user 
print(name) # Aybek 
print(age) # 22  
print(isMarried) # False  

"""Особенно удобно использовать кортежи, когда необходимо возвратить из функции сразу несколько значений. 
Когда функция возвращает несколько значений, фактически она возвращает в кортеж:
"""
def get_user():
   name = 'Dastan'
   age = 22 
   is_married = False 
   return name, age, is_married 

user = get_user() 
print(user[0]) # Dastan 
print(user[1]) # 22  
print(user[2]) # False 

"""
С помощью встроенной функции len() можно получить длину кортежа:
"""
user = ("Dastan", 22, False) 
print(len(user)) # 3 

"""Пустые списки vs пустые кортежи"""
"""
Пустой кортеж работает как синглтон, т.е. в памяти запущенного Python скрипта всегда находится только один пустой кортеж. 
Все пустые кортежи просто ссылаются на один и тот же объект, это возможно благодаря тому, что кортежи неизменяемы. 
Такой подход сохраняет много памяти и ускоряет процесс работы с пустыми кортежами.
"""
a = () 
b = () 
a is b # True 
id(a) # 4550426696 
id(b) # 4550426696 
# В CPython, функция id возвращает адрес в памяти.

"""Но это не работает со списками, ведь они могут быть изменены:"""
a = [] 
b = [] 
a is b # False 
id(a) # 4551471432 
id(b) # 4550897544 

"""Оптимизация выделения памяти для списков
Так как списки могут изменяться, такую же оптимизацию как в случае с кортежами провернуть уже не получится. 
Несмотря на это, для списков используется похожая оптимизация нацеленная на пустые списки. Если пустой список удаляется, 
то он так же может быть переиспользован в дальнейшем."""

a = [] 
id(a) # 4550897544 
del a 
b = [] 
id(b) # 4550897544 


"""
Перебор кортежей

Для перебора кортежа можно использовать стандартные циклы for и while. С помощью цикла for:
"""
user = ("Aybek", 22, False) 
for item in user: 
    print(item)
# Aybek 
# 22 
# False 

""" С помощью цикла while: """
user = ("Aybek", 22, False)
i = 0 
while i < len(user): 
    print(user[i]) 
    i += 1 
# Aybek 
# 22 
# False 

""" Как для списка с помощью выражения элемент in кортеж можно проверить наличие элемента в кортеже:"""
user = ("Aybek", 22, False) 
name = "Aybek" 
if name in user: 
    print("Пользователя зовут Aybek") 
else: 
    print("Пользователь имеет другое имя") 
# Пользователя зовут Aybek 

""" Сложные кортежи Один кортеж может содержать другие кортежи в виде элементов. Например: """
countries = ( 
    ("Germany", 80.2, (("Berlin",3.326),("Hamburg", 1.718))),
    ("France", 66, (("Paris", 2.2),("Marsel", 1.6)))
) 

for country in countries: 
    countryName, countryPopulation, cities = country 
    print("\nCountry: {} population: {}".format(countryName, countryPopulation)) 
    for city in cities: 
        cityName, cityPopulation = city 
        print("City: {} population: {}".format(cityName, cityPopulation))



""" Списки в кортежах
Кортежи могут содержать списки, также как списки быть вложенными в другие списки."""
nested = (1, "do", ["param", 10, 20])

""" Как вы думаете, можем ли мы изменить список ["param", 10, 20] вложенный в кортеж nested? Список изменяем!!!, 
кортеж – нет. Если вам кажется, что нельзя, то вам кажется неправильно. На самом деле можно!!!:"""

nested[2][1] = 15 
print(nested[2])
# ["param", 15, 20] 

# Note:. Выражения типа nested[2][1] используются для обращения к вложенным объектам. 
# Первый индекс указывает на позицию вложенного объекта, второй – индекс элемента внутри вложенного объекта. 
# Так в данном случае сам список внутри кортежа имеет индекс 2, а элемент списка 10 – индекс 1 в списке."""

""" Странная ситуация. Кортеж не изменяем, но мы все-таки можем изменить его. На самом деле кортеж остается неизменным. 
Просто в нем содержится не сам список, а ссылка на него. Ее изменить нельзя. Но менять сам список можно. 
Чтобы было проще понять, перепишем кортеж так:
"""
l = ["param", 10, 20] 
t = (1, "do", l) 
print(t)
# (1, 'do', ['param', 10, 20]) 

""" Кортеж содержит переменную-ссылку. Поменять ее на другую ссылку нельзя. Но кортеж не содержит самого списка.
Поэтому его можно менять как угодно:"""

l.pop(0) 
print(t)
# (1, 'do', [10, 20]) 


""" Однако помните, такой номер не прокатывает с неизменяемыми типами!!!!:"""
a = "Makers" 
t = (a, l) 
print(t) 
a = "Shakers" 
print(t) 
# ('Makers', [10, 20]) 

""" Они передаются в кортеж как и в функцию – по значению. 
Т. е. их значение копируется в момент передачи."""
